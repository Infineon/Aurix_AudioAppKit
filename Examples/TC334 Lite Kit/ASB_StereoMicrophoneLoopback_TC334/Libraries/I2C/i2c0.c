/*******************************************************************************
 * \file i2c.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/
#include "Ifx_reg.h"
#include "IfxCpu.h"
#include "ifxScuWdt.h"
#include "ports.h"
#include "i2c0_public.h"

#include "i2c0_private.h"


/* prototypes */
void i2c_SetDeviceAddress(uint8 address);

inline boolean i2c_Start(void);
boolean i2c_Stop(void);
boolean i2c_WriteDeviceAddress(boolean value);
boolean i2c_Write(uint8 *value, uint16 cnt);
boolean i2c_Read(uint8 *value, uint16 cnt);


/* local variables */
volatile i2c_status_type i2c_status;
volatile uint8 i2c_address;

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline void i2c_SetBit(uint16 value)
{
    PORT_SET = value; /* lower bits*/
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline void i2c_ClrBit(uint16 value)
{
    PORT_SET = (uint32) (value << 16); /* upper bits */
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline void i2c_SetDeviceAddress(uint8 address)
{
    i2c_address = address;
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
void i2c_delay(volatile uint32 value)
{
    while (value--)
    {

    };
}



/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline void i2c_WrBit(uint8 value)
{
    if (value > 0)
    {
        i2c_SetBit(SDA);
    }
    else
    {
        i2c_ClrBit(SDA);
    }

    i2c_delay(I2C_BIT_DELAY);
    i2c_SetBit(SCL);
    while((PORT_IN & SCL) == 0)
    {
        ; // wait for SCL to go high, clock stretching?
    }
    i2c_delay(I2C_BIT_DELAY);
    i2c_ClrBit(SCL);

    i2c_SetBit(SDA); /* release the line */
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline boolean i2c_RdBit(void)
{
    boolean result;

    /* wait for slave to output their data bit */
    i2c_delay(I2C_BIT_DELAY);
    i2c_SetBit(SCL);
    while((PORT_IN & SCL) == 0)
    {
        ; // wait for SCL to go high, clock stretching?
    }

    i2c_delay(I2C_BIT_DELAY);
    /* read the SDA just before we clear SCL */
    result = (PORT_IN & SDA) >> SDA_BIT;
    /* Always leave with the SCL line low */
    i2c_ClrBit(SCL);


    return (result);
}


/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline boolean i2c_Write(uint8 *value, uint16 cnt)
{
    uint32 bit;
    uint32 i;
    boolean acknowledge = FALSE;

    /* master write clocks out eight data bits that it writes */
    for (i = 0; i < cnt; i++)
    {
        for (bit = 0; bit < 8; bit++)
        {
            i2c_WrBit(I2C_MSB & value[i]);
            value[i] <<= 1;
        }
        /* master write clocks out the acknowledge bit that it reads */
        acknowledge = i2c_RdBit();
        if (acknowledge != 0)
        {
            /* the slave did not give us an ack */
            i2c_status = data_tx_master_nack;
        }
    }

    return acknowledge;
}


/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline boolean i2c_Read(uint8 *value, uint16 cnt)
{
    uint32 bit;
    uint32 i;
    boolean acknowledge = FALSE;

    for (i = 0; i < cnt; i++)
    {
        value[i] = 0;

        for (bit = 0; bit < 8; bit++)
        {
            value[i] <<= 1;
            value[i] |= i2c_RdBit();
        }
        if (i < (cnt - 1))
        {
            i2c_WrBit(I2C_ACK);
        }
        else
        {
            i2c_WrBit(I2C_NACK);
        }
    }
    return (acknowledge);
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline boolean i2c_WriteDeviceAddress(boolean value)
{
    uint32 bit;
    boolean acknowledge = FALSE;
    uint8 addr = i2c_address | value;

    for (bit = 0; bit < 8; bit++)
    {
        i2c_WrBit(I2C_MSB & addr);
        addr <<= 1;
    }
    acknowledge = i2c_RdBit();

    return (acknowledge);
}


/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline boolean i2c_Start(void)
{
    boolean status = E_NOT_OK;

    i2c_delay(I2C_BIT_DELAY/2);
    i2c_SetBit(SCL);
    i2c_delay(I2C_BIT_DELAY/2);

    if ((PORT_IN & READ_MASK) == READ_MASK)
    {
        i2c_ClrBit(SDA);
        i2c_delay(I2C_BIT_DELAY/2);
        i2c_ClrBit(SCL);
        i2c_delay(I2C_BIT_DELAY/2);

        if (i2c_status == bus_idle)
        {
            i2c_status = str_sent;
        }
        else
        {
            i2c_status = rpstr_sent;
        }
        status = E_OK;
    }
    else
    {
        i2c_status = bus_error;
    }

    return status;
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
inline boolean i2c_Stop(void)
{
    boolean status = E_NOT_OK;

    i2c_ClrBit(SDA);
    i2c_delay(I2C_BIT_DELAY*3);
    i2c_SetBit(SCL);
    i2c_delay(I2C_BIT_DELAY*2);
    i2c_SetBit(SDA);
    i2c_delay(I2C_BIT_DELAY/2);

    /* need to end with the bus idle, both SDA and SCL high */
    if ((PORT_IN & READ_MASK) == READ_MASK)
    {
        i2c_status = stp_sent;
        status = E_OK;
    }
    else
    {
        i2c_status = bus_error;
    }

    return status;
}


/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
boolean I2C0_Write(uint8 slaveAddress, uint8 *data, uint16 len)
{
    boolean status = E_NOT_OK;

    if (i2c_status == bus_idle)
    {
        i2c_SetDeviceAddress(I2C_ADDR(slaveAddress));

        if (i2c_Start() == E_OK)
        {
            if (i2c_WriteDeviceAddress(I2C_WRITE) == ack)
            {
                i2c_Write(data, len);
            }
            else
            {
                /* device was not found */
                i2c_status = addr_wr_nack;
            }

            i2c_Stop();
        }
    }

    if (stp_sent == i2c_status)
    {
        i2c_status = bus_idle;
        status = E_OK;
    }

    return status;
}


/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
boolean I2C0_Read(uint8 slaveAddress, uint8 *data, uint8 addrLen, uint16 len)
{

    boolean status = E_NOT_OK;

    if (i2c_status == bus_idle)
    {
        i2c_SetDeviceAddress(I2C_ADDR(slaveAddress));

        /* Write portion of the message */
        if (i2c_Start() == E_OK)
        {
            if (i2c_WriteDeviceAddress(I2C_WRITE) == ack)
            {
                    if (i2c_Write(data, addrLen) == E_OK)
                    {
                        if (i2c_Start() == E_OK)
                        {
                            if (i2c_WriteDeviceAddress(I2C_READ) == ack)
                            {
                                status = i2c_Read(&data[0], len);
                            }
                        }
                    }
            }
            else
            {
                /* device was not found */
                i2c_status = addr_rd_nack;
            }
            i2c_Stop();
        }
    }

    if (stp_sent == i2c_status)
    {
        i2c_status = bus_idle;
        status = E_OK;
    }

    return status;
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
boolean I2C0_Reset(void)
{
    boolean status = E_NOT_OK;

    i2c_ClrBit(SCL);
    i2c_delay(I2C_BIT_DELAY);
    i2c_ClrBit(SDA);
    i2c_delay(I2C_BIT_DELAY);

    /* now clock 16 times */
    for (uint32 i = 0; i < 16; i++)
    {
        i2c_SetBit(SCL);
        i2c_delay(I2C_BIT_DELAY );
        i2c_ClrBit(SCL);
        i2c_delay(I2C_BIT_DELAY );
    }

    i2c_Stop();

    if ((PORT_IN & READ_MASK) == READ_MASK)
    {
        status = E_OK;
        i2c_status = bus_idle;
    }

    return (status);
}

/** \brief
 *
 * \param
 * \return
 *
 * \ingroup
 */
boolean I2C0_Init(void)
{
    boolean status = E_NOT_OK;

    /* set both SCL and SDA high */
    PORT_SET = READ_MASK;
    /* SCL and SDA pins must be configured as open drain */
    PORT_IOCR_SCL = PCx_Output_OpenDrain_gpio;
    PORT_IOCR_SDA = PCx_Output_OpenDrain_gpio;

    if ((PORT_IN & READ_MASK) == READ_MASK)
    {
        status = E_OK;
        i2c_status = bus_idle;
    }

    return (status);
}


/*************************************************************************
 Development history of the file



*************************************************************************/
