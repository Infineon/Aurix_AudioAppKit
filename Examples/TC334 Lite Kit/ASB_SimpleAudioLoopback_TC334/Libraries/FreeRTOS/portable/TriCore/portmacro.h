/**
 * \file portmacro.h
 * \brief FreeRTOS portable file which defines the TriCore specific macros.
 *
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *                               IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef PORTMACRO_H
#define PORTMACRO_H

#ifdef __cplusplus
    extern "C" {
#endif

/* System Includes. */
#include <stdint.h>

/* TriCore specific includes. */
#include "port_tricore.h"

/*-----------------------------------------------------------
 * Port specific definitions.
 *
 * The settings in this file configure FreeRTOS correctly for the
 * given hardware and compiler.
 *
 * These settings should not be altered.
 *-----------------------------------------------------------
 */

/* Type definitions. */
#define portCHAR          char
#define portFLOAT         float
#define portDOUBLE        double
#define portLONG          long
#define portSHORT         short
#define portSTACK_TYPE    unsigned long
#define portBASE_TYPE     long

typedef portSTACK_TYPE   StackType_t;
typedef long             BaseType_t;
typedef unsigned long    UBaseType_t;

#if ( configUSE_16_BIT_TICKS == 1 )
    typedef unsigned     TickType_t;
    #define portMAX_DELAY              ( TickType_t ) 0xffff
#else
    typedef unsigned     TickType_t;
    #define portMAX_DELAY              ( TickType_t ) 0xffffffffUL

    /* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
     * not need to be guarded with a critical section. */
    #define portTICK_TYPE_IS_ATOMIC    1
#endif
/*---------------------------------------------------------------------------*/

/* Architecture specifics. */
#define portSTACK_GROWTH               ( -1 )
#define portTICK_PERIOD_MS             ( ( TickType_t ) 1000 / configTICK_RATE_HZ )
#define portBYTE_ALIGNMENT             4
#define portASSERT_IF_IN_ISR()    vPortAssertIfInISR()
#define portNOP()                 TriCore__nop()
#define portCRITICAL_NESTING_IN_TCB    1

extern void vTaskEnterCritical( void );
extern void vTaskExitCritical( void );
extern __attribute__( ( __noreturn__ ) ) void vPortLoopForever( void );
#define portENTER_CRITICAL()    vTaskEnterCritical()
#define portEXIT_CRITICAL()     vTaskExitCritical()

extern inline void vPortYield( void );
#define portYIELD()             vPortYield()

#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() vPortConfigureTimeForRunTimeStats()
#define portGET_RUN_TIME_COUNTER_VALUE()    vPortGetRunTimeCounterValue()

/* Syscall IDs */
#define portSYSCALL_TASK_YIELD    0

/* Critical section management. */
#define portCCPN_MASK             ( 0x000000FFUL )
/* Set ICR.CCPN to configMAX_SYSCALL_INTERRUPT_PRIORITY. */
#define portDISABLE_INTERRUPTS()                                                                      \
    {                                                                                                 \
        unsigned long ulICR;                                                                          \
        TriCore__disable();                                                                           \
        ulICR = TriCore__mfcr( TRICORE_CPU_ICR );      /* Get current ICR value. */                   \
        ulICR &= ~portCCPN_MASK;                       /* Clear down mask bits. */                    \
        ulICR |= configMAX_SYSCALL_INTERRUPT_PRIORITY; /* Set mask bits to required priority mask. */ \
        TriCore__mtcr( TRICORE_CPU_ICR, ulICR );       /* Write back updated ICR. */                  \
        TriCore__isync();                                                                             \
        TriCore__enable();                                                                            \
    }

/* Clear ICR.CCPN to allow all interrupt priorities. */
#define portENABLE_INTERRUPTS()                                                 \
    {                                                                           \
        unsigned long ulICR;                                                    \
        TriCore__disable();                                                     \
        ulICR = TriCore__mfcr( TRICORE_CPU_ICR ); /* Get current ICR value. */  \
        ulICR &= ~portCCPN_MASK;                  /* Clear down mask bits. */   \
        TriCore__mtcr( TRICORE_CPU_ICR, ulICR );  /* Write back updated ICR. */ \
        TriCore__isync();                                                       \
        TriCore__enable();                                                      \
    }

/* Set ICR.CCPN to uxSavedMaskValue. */
#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedMaskValue )                                         \
    {                                                                                                 \
        unsigned long ulICR;                                                                          \
        TriCore__disable();                                                                           \
        ulICR = TriCore__mfcr( TRICORE_CPU_ICR ); /* Get current ICR value. */                        \
        ulICR &= ~portCCPN_MASK;                  /* Clear down mask bits. */                         \
        ulICR |= uxSavedMaskValue;                /* Set mask bits to previously saved mask value. */ \
        TriCore__mtcr( TRICORE_CPU_ICR, ulICR );  /* Write back updated ICR. */                       \
        TriCore__isync();                                                                             \
        TriCore__enable();                                                                            \
    }


/* Set ICR.CCPN to configMAX_SYSCALL_INTERRUPT_PRIORITY */
#define portSET_INTERRUPT_MASK_FROM_ISR()                     uxPortSetInterruptMaskFromISR()

/* Pend a priority 1 interrupt, which will take care of the context switch. */
#define portYIELD_FROM_ISR( xHigherPriorityTaskWoken )        if( xHigherPriorityTaskWoken != pdFALSE ) { portYIELD(); }

/* Task function macros as described on the FreeRTOS.org WEB site. */
#define portTASK_FUNCTION_PROTO( vFunction, pvParameters )    void vFunction( void * pvParameters )
#define portTASK_FUNCTION( vFunction, pvParameters )          void vFunction( void * pvParameters )


/*
 * Port specific clean up macro required to free the CSAs that were consumed by
 * a task that has since been deleted.
 */
extern void vPortReclaimCSA( unsigned long * pxTCB );
#define portCLEAN_UP_TCB( pxTCB )    vPortReclaimCSA( ( unsigned long * ) ( pxTCB ) )

#define portMEMORY_BARRIER()         TriCore__mem_barrier()

TRICORE_CINLINE unsigned long uxPortSetInterruptMaskFromISR( void )
{
    unsigned long uxReturn = 0UL;

    TriCore__disable();
    uxReturn = TriCore__mfcr( TRICORE_CPU_ICR );
    TriCore__mtcr( TRICORE_CPU_ICR, ( ( uxReturn & ~portCCPN_MASK ) | configMAX_SYSCALL_INTERRUPT_PRIORITY ) );
    TriCore__isync();
    TriCore__enable();

    /* Return just the interrupt mask bits. */
    return( uxReturn & portCCPN_MASK );
}

TRICORE_CINLINE void vPortAssertIfInISR( void )
{
    configASSERT( ( TriCore__mfcr( TRICORE_CPU_PSW ) & ( 1U << 9U ) ) == 0x00000000U );
}

#ifdef __cplusplus
    }
#endif

#endif /* PORTMACRO_H */
