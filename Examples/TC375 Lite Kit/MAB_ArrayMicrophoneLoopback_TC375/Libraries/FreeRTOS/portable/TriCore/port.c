/**
 * \file port.c
 * \brief File defining the FreeRTOS portable functions towards TriCore CPUs
 *
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *                               IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
/* Std includes */
#include <string.h>

/* Kernel includes. */
#include "FreeRTOS.h"
#include "task.h"

/* IFX include */
#include <Src/Std/IfxSrc.h>
#include <Stm/Timer/IfxStm_Timer.h>

/* Prgoram status word macros */
#define portINITIAL_SYSTEM_PSW          ( 0x000008FFUL ) /* Supervisor Mode, MPU Register Set 0 and Call Depth Counting disabled. */
#define portINITIAL_PRIVILEGED_PSW      ( 0x000014FFUL ) /* IO Level 1, MPU Register Set 1 and Call Depth Counting disabled. */
#define portINITIAL_UNPRIVILEGED_PSW    ( 0x000010FFUL ) /* IO Level 0, MPU Register Set 1 and Call Depth Counting disabled. */
#define portRESTORE_PSW_MASK            ( ~( 0x000000FFUL ) )

/* Context save area macros */
#define portCSA_TO_ADDRESS( pCSA )                            \
    ( ( unsigned long * ) ( ( ( pCSA & 0x000F0000 ) << 12 ) | \
                            ( ( pCSA & 0x0000FFFF ) << 6 ) ) )
#define portADDRESS_TO_CSA( pAddress )                                            \
    ( ( unsigned long ) ( ( ( ( unsigned long ) pAddress & 0xF0000000 ) >> 12 ) | \
                          ( ( ( unsigned long ) pAddress & 0x003FFFC0 ) >> 6 ) ) )
#define portCSA_FCX_MASK        ( 0x000FFFFFUL )
#define portINITIAL_LOWER_PCXI  ( 0x00300000UL ) /* Set UL to upper and PIE to 1 */
#define portINITIAL_UPPER_PCXI  ( 0x00200000UL ) /* Set UL to lower and PIE to 1 */
#define portNUM_WORDS_IN_CSA    ( 16 )

/* This reference is required by the save/restore context macros. */
extern volatile unsigned long * pxCurrentTCB;

#define portTICK_COUNT    ( configSTM_CLOCK_HZ / configTICK_RATE_HZ )
IFX_INLINE void vPortInitTickTimer()
{
    IfxStm_CompareConfig stm_config;

    IfxStm_initCompareConfig( &stm_config );
    stm_config.comparator = IfxStm_Comparator_0;
    stm_config.comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;
    stm_config.compareOffset = IfxStm_ComparatorOffset_0;
    stm_config.compareSize = IfxStm_ComparatorSize_32Bits;
    stm_config.ticks = IfxStm_getLower( &configSTM_MODULE ) + portTICK_COUNT;
    stm_config.triggerPriority = configKERNEL_INTERRUPT_PRIORITY + 1;
    stm_config.typeOfService = configSTM_TOS;
    IfxStm_initCompare( &configSTM_MODULE, &stm_config );
}

IFX_INLINE void vPortInitContextSrc()
{
    IfxSrc_init( &configCONTEXT_SRC, configCONTEXT_TOS, configKERNEL_INTERRUPT_PRIORITY );
    IfxSrc_enable( &configCONTEXT_SRC );
}

TRICORE_CINLINE void vPortYield()
{
    if( IfxSrc_isRequested( &configCONTEXT_SRC ) != TRUE )
    {
        IfxSrc_setRequest( &configCONTEXT_SRC );
    }

    TriCore__dsync();
    TriCore__isync();
}

TRICORE_NOINLINE void vPortStartFirstTask()
{
    unsigned long ** ppxTopOfStack;
    unsigned long uxLowerCSA;

    TriCore__dsync();
    /* Load the new CSA id from the stack and update the stack pointer */
    ppxTopOfStack = ( unsigned long ** ) pxCurrentTCB;
    uxLowerCSA = **ppxTopOfStack;
    ( *ppxTopOfStack )++;

    /* Update the link register */
    TriCore__mtcr( TRICORE_CPU_PCXI, uxLowerCSA );
    TriCore__isync();

    /* Disable interrupts and reset the interrupt mask. IRQs will be enabled through context PCXI */
    TriCore__disable();
    unsigned long ulICR = TriCore__mfcr( TRICORE_CPU_ICR );
    ulICR &= ~portCCPN_MASK;
    TriCore__mtcr( TRICORE_CPU_ICR, ulICR );

    /* Load the lower context, upper context is loaded through the return */
    TriCore__rslcx();
}

StackType_t *pxPortInitialiseStack( StackType_t * pxTopOfStack,
                                    TaskFunction_t pxCode,
                                    void * pvParameters )
{
    unsigned long * pulUpperCSA = NULL;
    unsigned long * pulLowerCSA = NULL;

    /* Have to disable interrupts here because the CSAs are going to be
     * manipulated. */
    TriCore__disable();
    {
        /* DSync to ensure that buffering is not a problem. */
        TriCore__dsync();

        /* Consume two free CSAs. */
        pulLowerCSA = portCSA_TO_ADDRESS( TriCore__mfcr( TRICORE_CPU_FCX ) );

        if( NULL != pulLowerCSA )
        {
            /* The Lower Links to the Upper. */
            pulUpperCSA = portCSA_TO_ADDRESS( pulLowerCSA[ 0 ] );
        }

        /* Check that we have successfully reserved two CSAs. */
        if( ( NULL != pulLowerCSA ) && ( NULL != pulUpperCSA ) )
        {
            /* Remove the two consumed CSAs from the free CSA list. */
            TriCore__mtcr( TRICORE_CPU_FCX, pulUpperCSA[ 0 ] );
            #ifndef __TASKING__
                TriCore__isync();
            #endif
        }
        else
        {
            /* Simply trigger a context list depletion trap. */
            TriCore__svlcx();
        }
    }
    TriCore__enable();

    /* Upper Context. */
    memset( pulUpperCSA, 0, portNUM_WORDS_IN_CSA * sizeof( unsigned long ) );
    pulUpperCSA[ 2 ] = ( unsigned long ) pxTopOfStack; /* A10;    Stack Return aka Stack Pointer */
    pulUpperCSA[ 1 ] = portINITIAL_SYSTEM_PSW;         /* PSW    */
    pulUpperCSA[ 0 ] = portINITIAL_UPPER_PCXI;

    /* Lower Context. */
    memset( pulLowerCSA, 0, portNUM_WORDS_IN_CSA * sizeof( unsigned long ) );
    pulLowerCSA[ 8 ] = ( unsigned long ) pvParameters; /* A4;    Address Type Parameter Register    */
    pulLowerCSA[ 1 ] = ( unsigned long ) pxCode;       /* A11;    Return Address aka RA */
    pulLowerCSA[ 0 ] = ( portINITIAL_LOWER_PCXI | ( unsigned long ) portADDRESS_TO_CSA( pulUpperCSA ) ); /* PCXI pointing to the Upper context. */

    /* Save the link to the CSA to the top of stack. */
    pxTopOfStack--;
    *pxTopOfStack = portADDRESS_TO_CSA( pulLowerCSA );

    return pxTopOfStack;
}

BaseType_t xPortStartScheduler( void )
{
    vPortInitTickTimer();
    vPortInitContextSrc();
    vPortStartFirstTask();

    return 0;
}

void vPortEndScheduler()
{
    IfxSrc_disable( &configCONTEXT_SRC );
    IfxStm_disableModule( &configSTM_MODULE );
}

IFX_INTERRUPT( vPortSystemContextHandler, configCONTEXT_TOS, configKERNEL_INTERRUPT_PRIORITY )
{
    unsigned long ** ppxTopOfStack;
    unsigned long uxLowerCSA;
    unsigned long * pxLowerCSA, * pxUpperCSA;

    TriCore__disable();
    {
        TriCore__dsync();
        /* Load the current top of stack pointer and csa info */
        ppxTopOfStack = ( unsigned long ** ) pxCurrentTCB;
        uxLowerCSA = TriCore__mfcr( TRICORE_CPU_PCXI );
        pxLowerCSA = portCSA_TO_ADDRESS( uxLowerCSA );
        pxUpperCSA = portCSA_TO_ADDRESS( pxLowerCSA[ 0 ] );
        /* Update the stack info in the TCB */
        *ppxTopOfStack = ( unsigned long * ) pxUpperCSA[ 2 ];
        /* Place the lower CSA id on the stack */
        ( *ppxTopOfStack )--;
        **ppxTopOfStack = uxLowerCSA;

        vTaskSwitchContext();

        /* Load the new CSA id from the new stack and update the stack pointer */
        ppxTopOfStack = ( unsigned long ** ) pxCurrentTCB;
        uxLowerCSA = **ppxTopOfStack;
        ( *ppxTopOfStack )++;
        /* Update the link register */
        TriCore__mtcr( TRICORE_CPU_PCXI, uxLowerCSA );
        TriCore__isync();
    }
    TriCore__enable();
}

IFX_INTERRUPT( vPortSystemTickHandler, configSTM_TOS, configKERNEL_INTERRUPT_PRIORITY + 1 )
{
    unsigned long ulSavedInterruptMask;
    long lYieldRequired;

    IfxStm_increaseCompare( &configSTM_MODULE, IfxStm_Comparator_0, portTICK_COUNT );

    /* Kernel API calls require Critical Sections. */
    ulSavedInterruptMask = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Increment the Tick. */
        lYieldRequired = xTaskIncrementTick();
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( ulSavedInterruptMask );

    configASSERT((IfxStm_getCompare(&configSTM_MODULE, IfxStm_Comparator_0) - IfxStm_getLower(&configSTM_MODULE)) <= portTICK_COUNT);
    if( ( lYieldRequired != pdFALSE ) && ( IfxSrc_isRequested( &configCONTEXT_SRC ) != TRUE ) )
    {
        IfxSrc_setRequest( &configCONTEXT_SRC );
    }
}

/*-----------------------------------------------------------*/

/*
 * When a task is deleted, it is yielded permanently until the IDLE task
 * has an opportunity to reclaim the memory that that task was using.
 * Typically, the memory used by a task is the TCB and Stack but in the
 * TriCore this includes the CSAs that were consumed as part of the Call
 * Stack. These CSAs can only be returned to the Globally Free Pool when
 * they are not part of the current Call Stack, hence, delaying the
 * reclamation until the IDLE task is freeing the task's other resources.
 * This function uses the head of the linked list of CSAs (from when the
 * task yielded for the last time) and finds the tail (the very bottom of
 * the call stack) and inserts this list at the head of the Free list,
 * attaching the existing Free List to the tail of the reclaimed call stack.
 *
 * NOTE: the IDLE task needs processing time to complete this function
 * and in heavily loaded systems, the Free CSAs may be consumed faster
 * than they can be freed assuming that tasks are being spawned and
 * deleted frequently.
 */
void vPortReclaimCSA( unsigned long * pxTCB )
{
    unsigned long pxHeadCSA, pxTailCSA, pxFreeCSA;
    unsigned long * pulNextCSA;

    /* A pointer to the first CSA in the list of CSAs consumed by the task is
     * stored in the first element of the tasks TCB structure (where the stack
     * pointer would be on a traditional stack based architecture). */
    pxHeadCSA = ( *pxTCB ) & portCSA_FCX_MASK;

    /* Mask off everything in the CSA link field other than the address.  If
     * the address is NULL, then the CSA is not linking anywhere and there is
     * nothing to do. */
    pxTailCSA = pxHeadCSA;

    /* Convert the link value to contain just a raw address and store this
     * in a local variable. */
    pulNextCSA = portCSA_TO_ADDRESS( pxTailCSA );

    /* Iterate over the CSAs that were consumed as part of the task.  The
     * first field in the CSA is the pointer to then next CSA.  Mask off
     * everything in the pointer to the next CSA, other than the link address.
     * If this is NULL, then the CSA currently being pointed to is the last in
     * the chain. */

    while( 0UL != ( pulNextCSA[ 0 ] & portCSA_FCX_MASK ) )
    {
        /* Clear all bits of the pointer to the next in the chain, other
         * than the address bits themselves. */
        pulNextCSA[ 0 ] = pulNextCSA[ 0 ] & portCSA_FCX_MASK;

        /* Move the pointer to point to the next CSA in the list. */
        pxTailCSA = pulNextCSA[ 0 ];

        /* Update the local pointer to the CSA. */
        pulNextCSA = portCSA_TO_ADDRESS( pxTailCSA );
    }

    TriCore__disable();
    {
        /* Look up the current free CSA head. */
        TriCore__dsync();
        pxFreeCSA = TriCore__mfcr( TRICORE_CPU_FCX );

        /* Join the current Free onto the Tail of what is being reclaimed. */
        portCSA_TO_ADDRESS( pxTailCSA )[ 0 ] = pxFreeCSA;

        /* Move the head of the reclaimed into the Free. */
        TriCore__dsync();
        TriCore__mtcr( TRICORE_CPU_FCX, pxHeadCSA );
        TriCore__isync();
    }
    TriCore__enable();
}

__attribute__( ( __noreturn__ ) ) void vPortLoopForever( void )
{
    while( 1 )
    {
    }
}
